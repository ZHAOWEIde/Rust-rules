# Rust-rules入门
rust语法规则，rust程序语言设计第二版
## 1、所有权
+ 所有权？
  - 通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查。

+ 栈（Stack）与堆（Heap）
  - 餐馆吃饭堆操作
  - 叠盘子栈操作
  - 栈入栈快、访存快
  - 数据类型大小固定在栈上、否则堆上
+ 权系统要处理的问题？
  - 跟踪哪部分代码正在使用堆上的哪些数据，最大限度的减少堆上的重复数据的数量，以及清理堆上不再使用的数据确保不会耗尽空间
  - 所有权的存在就是为了管理堆数据
+ 所有权规则
  - Rust 中的每一个值都有一个被称为其 所有者（owner）的变量。
  - 值有且只有一个所有者。
  - 当所有者（变量）离开作用域，这个值将被丢弃。
+ 变量作用域
  - String 类型 let s = String::from("hello");
    - move 浅拷贝、不会自动深拷贝 对于堆数据
    - clone 强行复制
    - 拷贝的特性（能copy的）：
      - int
      - float
      - bool
      - ...
  - 所有权和函数
    - 引用 & 我理解为指针 不传递所有权
      - 不能修改借来的变量
    - 可变引用 &mut
      - 可变引用有一个很大的限制：在特定作用域中的特定数据有且只有一个可变引用
      - 可以拥有多个&mut,但是一个作用域域只能有一个，防止数据竞争
      - 不能同时使用 可变 和不可变引用，有点问题这里，不可变引用的作用域是？
        -使用可变引用后 不能再在该作用域使用不可变引用
  - 悬垂引用
    - 概念：悬垂指针是其指向的内存可能已经被分配给其它持有者
  - Slice 类型 &str
    - 飘忽不定的不相关变量需要保持同步
    - string 类型的会有问题
## 2、结构体
  - ..语法
  - 使用没有命名字段的元组结构体来创建不同的类型
  - 没有任何字段的类单元结构体
  - 方法语法
    - 方法impl
    - 关联函数 在impl中定义函数，而不是方法
      - 使用：：调用关联函数
    - 多个impl块：分开写是可以的
## 3、枚举和模式匹配
  
